# 垃圾回收

## 数据存储

- 基础数据类型(栈内存)
- 引用数据类型(堆内存)

## 调用栈中的数据是如何回收的

- 例子

```js
function foo() {
  var a = 1;
  var b = { name: 'cz' };
  function showName() {
    var c = 2;
    var d = { name: 'cz1' };
  }
  showName();
}
```

- 分析执行上下文

```js
FooContext = {
    a:1,
    b: 堆地址1
}
ShowNameContext = {
    c:2,
    d: 堆内存地址2
}
当执行到showName函数时，会将showNameContext压人执行上下文栈中，同时还有一个记录当前执行状态的指针(esp)，表示当前正在执行的上下文。
当showName函数执行完成，执行流程回到foo函数，这时候需要销毁showName函数的执行上下文，js会将esp下移到foo函数的执行上下文。
```

## 堆中数据是如何回收的

当 foo 函数执行完成，esp 指向全局执行上下文，showName 和 Foo 函数执行上下文在内存变成无效状态。但是还有 b,c 两个对象存在堆内存中。要回收堆内存中的垃圾数据，就需要用到 js 中的垃圾回收器了。

- 代际假说

```
1. 大部分对象在内存中存在的时间很短，很多对象一经分配内存，很快就变得不可访问。
2. 不死的对象，会活动更久。
```

- v8 如何实现垃圾回收

```
v8会把堆内存分为新生代和老生代两个区域。
新生代： 存生存时间短的对象(1~8M容量)(副垃圾回收器)
老生代： 存生存时间长的对象(主垃圾回收器)

```

执行流程

```
1. 标记空间中的活动对象和非活动对象。
2. 回收非活动对象所占的内存
3. 内存整理。频繁回收对象后，内存中会存在大量不连续的空间(内存碎片)
```

副垃圾回收器

```js
Scavenge 算法: 把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，新加入的对象会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理。
在垃圾回收过程中，首先对对象区域中的垃圾做标记；标记完成后，副垃圾回收器会把存活的对象复制到空闲区域，并排序。然后将对象区域和空间区域进行角色翻转。
对象晋升策略：经过两次垃圾回收依然还存活的对象，会被移动到老生代区域。
```

主垃圾回收器

```
主垃圾回收器主要采用标记清除法来进行垃圾回收。
1. 标记阶段
从一组根元素，遍历这组根元素，在这个遍历过程中，能到达的元素为活动对象，没有到达的元素为垃圾数据。
2. 清理阶段
将所有标记的垃圾数据全部清楚。（产生大量连续的内存碎片，导致大对象无法分配到足够的内存空间，产生了另外一种算法-标记整理法）
标记整理法
1. 标记阶段一样
2. 清理阶段不是直接对可回收的对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。
```

## 全停顿

js 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将 js 脚本暂停，等待垃圾回收完成后在恢复脚本执行。

- 案例

```
页面正在执行一个js动画，因为垃圾回收器正在工作，就会导致动画在一段时间内无法执行，导致卡顿，那么如何解决这个问题呢？
```

- 增量标记算法

```
为了降低老生代的垃圾回收造成的卡顿，v8将标记过程分为一个一个的子标记过程，同时让垃圾回收标记和js逻辑交替进行，直到标记完成。
```
